<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cheshirekow: Bitonic Sorting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cheshirekow
   &#160;<span id="projectnumber">v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__bitonic.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bitonic Sorting</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpblocks_1_1cuda_1_1bitonic_1_1_sorter.html">mpblocks::cuda::bitonic::Sorter&lt; KeyType, ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for calculating properties of the bitonic sort kernels.  <a href="classmpblocks_1_1cuda_1_1bitonic_1_1_sorter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab73cd6e0410f9cb3334aefd4a9905291"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:gab73cd6e0410f9cb3334aefd4a9905291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="portable_8h.html#ad54e07d96efd9a36dfca1a9f27776d62">__device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#gab73cd6e0410f9cb3334aefd4a9905291">mpblocks::cuda::bitonic::compareSwap</a> (KeyType &amp;keyA, ValueType &amp;valA, KeyType &amp;keyB, ValueType &amp;valB, Direction dir)</td></tr>
<tr class="memdesc:gab73cd6e0410f9cb3334aefd4a9905291"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements a "comparator": compares to keys and swaps them if they are not in the desired order  <a href="#gab73cd6e0410f9cb3334aefd4a9905291">More...</a><br/></td></tr>
<tr class="separator:gab73cd6e0410f9cb3334aefd4a9905291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c9b60745c24c58da5294bc5ebf52b3"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga88c9b60745c24c58da5294bc5ebf52b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="portable_8h.html#ad54e07d96efd9a36dfca1a9f27776d62">__device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga88c9b60745c24c58da5294bc5ebf52b3">mpblocks::cuda::bitonic::compareSwap</a> (KeyType &amp;keyA, KeyType &amp;keyB, Direction dir)</td></tr>
<tr class="memdesc:ga88c9b60745c24c58da5294bc5ebf52b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares to keys and swaps them if they are not in the desired order  <a href="#ga88c9b60745c24c58da5294bc5ebf52b3">More...</a><br/></td></tr>
<tr class="separator:ga88c9b60745c24c58da5294bc5ebf52b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad8e13f8c3a5ad69912635d2a5fb73a"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga3ad8e13f8c3a5ad69912635d2a5fb73a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga3ad8e13f8c3a5ad69912635d2a5fb73a">mpblocks::cuda::bitonic::mergeGlobal</a> (KeyType *d_DstKey, ValueType *d_DstVal, KeyType *d_SrcKey, ValueType *d_SrcVal, uint_t arrayLength, uint_t size, uint_t stride, Direction dir)</td></tr>
<tr class="memdesc:ga3ad8e13f8c3a5ad69912635d2a5fb73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts a bitonic series, this kernel is for a stride &gt;= SHARED_SIZE_LIMIT  <a href="#ga3ad8e13f8c3a5ad69912635d2a5fb73a">More...</a><br/></td></tr>
<tr class="separator:ga3ad8e13f8c3a5ad69912635d2a5fb73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b02960e723f46679d591e91d5fd985"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga34b02960e723f46679d591e91d5fd985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga34b02960e723f46679d591e91d5fd985">mpblocks::cuda::bitonic::mergeGlobal</a> (KeyType *d_DstKey, KeyType *d_SrcKey, uint_t arrayLength, uint_t size, uint_t stride, Direction dir)</td></tr>
<tr class="memdesc:ga34b02960e723f46679d591e91d5fd985"><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts a bitonic series, this kernel is for a stride &gt;= SHARED_SIZE_LIMIT  <a href="#ga34b02960e723f46679d591e91d5fd985">More...</a><br/></td></tr>
<tr class="separator:ga34b02960e723f46679d591e91d5fd985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b684229b12eee4d4f9ce59fb9bb285"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:gae1b684229b12eee4d4f9ce59fb9bb285"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#gae1b684229b12eee4d4f9ce59fb9bb285">mpblocks::cuda::bitonic::mergeShared</a> (KeyType *d_DstKey, ValueType *d_DstVal, KeyType *d_SrcKey, ValueType *d_SrcVal, uint_t arrayLength, uint_t sharedLength, uint_t size, Direction dir)</td></tr>
<tr class="memdesc:gae1b684229b12eee4d4f9ce59fb9bb285"><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts a bitonic series, this kernel is for size &gt; SHARED_SIZE_LIMIT and for a stride in [1, SHARED_SIZE_LIMIT/2]  <a href="#gae1b684229b12eee4d4f9ce59fb9bb285">More...</a><br/></td></tr>
<tr class="separator:gae1b684229b12eee4d4f9ce59fb9bb285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7672696f99e35730ee3f0af83e41e7"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga1b7672696f99e35730ee3f0af83e41e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga1b7672696f99e35730ee3f0af83e41e7">mpblocks::cuda::bitonic::mergeShared</a> (KeyType *d_DstKey, KeyType *d_SrcKey, uint_t arrayLength, uint_t sharedLength, uint_t size, Direction dir)</td></tr>
<tr class="memdesc:ga1b7672696f99e35730ee3f0af83e41e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts a bitonic series, this kernel is for size &gt; SHARED_SIZE_LIMIT and for a stride in [1, SHARED_SIZE_LIMIT/2]  <a href="#ga1b7672696f99e35730ee3f0af83e41e7">More...</a><br/></td></tr>
<tr class="separator:ga1b7672696f99e35730ee3f0af83e41e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf546b42a8c8b28e40a376ebf90af43a"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:gaaf546b42a8c8b28e40a376ebf90af43a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#gaaf546b42a8c8b28e40a376ebf90af43a">mpblocks::cuda::bitonic::prepare</a> (KeyType *d_SrcKey, KeyType init, uint_t arrayLength)</td></tr>
<tr class="memdesc:gaaf546b42a8c8b28e40a376ebf90af43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">used when arrayLength is not a power of two, it writes  to all values of d_SrcKey (which is an offset from of the actual source buffer)  <a href="#gaaf546b42a8c8b28e40a376ebf90af43a">More...</a><br/></td></tr>
<tr class="separator:gaaf546b42a8c8b28e40a376ebf90af43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075a351073741ddb3727c3257c9b307f"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga075a351073741ddb3727c3257c9b307f"><td class="memTemplItemLeft" align="right" valign="top">uint_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga075a351073741ddb3727c3257c9b307f">mpblocks::cuda::bitonic::sort</a> (KeyType *d_DstKey, ValueType *d_DstVal, KeyType *d_SrcKey, ValueType *d_SrcVal, uint_t arrayLength, uint_t sharedLength, Direction dir, uint_t globalThread)</td></tr>
<tr class="memdesc:ga075a351073741ddb3727c3257c9b307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel launcher, sorts an array of key/value pairs using the bitonic sort algorithm  <a href="#ga075a351073741ddb3727c3257c9b307f">More...</a><br/></td></tr>
<tr class="separator:ga075a351073741ddb3727c3257c9b307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afcc03653463ced68a00866e763da40"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga6afcc03653463ced68a00866e763da40"><td class="memTemplItemLeft" align="right" valign="top">uint_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga6afcc03653463ced68a00866e763da40">mpblocks::cuda::bitonic::sort</a> (KeyType *d_DstKey, KeyType *d_SrcKey, uint_t arrayLength, uint_t sharedLength, Direction dir, uint_t globalThread)</td></tr>
<tr class="memdesc:ga6afcc03653463ced68a00866e763da40"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel launcher, sorts an array of key/value pairs using the bitonic sort algorithm  <a href="#ga6afcc03653463ced68a00866e763da40">More...</a><br/></td></tr>
<tr class="separator:ga6afcc03653463ced68a00866e763da40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6674656e30bc37adf3f8f488b8ab9d3a"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga6674656e30bc37adf3f8f488b8ab9d3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga6674656e30bc37adf3f8f488b8ab9d3a">mpblocks::cuda::bitonic::sortShared</a> (KeyType *d_DstKey, ValueType *d_DstVal, KeyType *d_SrcKey, ValueType *d_SrcVal, uint_t arrayLength, Direction dir)</td></tr>
<tr class="memdesc:ga6674656e30bc37adf3f8f488b8ab9d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">single kernel (unified) bitonic sort  <a href="#ga6674656e30bc37adf3f8f488b8ab9d3a">More...</a><br/></td></tr>
<tr class="separator:ga6674656e30bc37adf3f8f488b8ab9d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027f22dab31d842be2dfd9550cb091cd"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga027f22dab31d842be2dfd9550cb091cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga027f22dab31d842be2dfd9550cb091cd">mpblocks::cuda::bitonic::sortShared</a> (KeyType *d_DstKey, KeyType *d_SrcKey, uint_t arrayLength, Direction dir)</td></tr>
<tr class="memdesc:ga027f22dab31d842be2dfd9550cb091cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">single kernel (unified) bitonic sort  <a href="#ga027f22dab31d842be2dfd9550cb091cd">More...</a><br/></td></tr>
<tr class="separator:ga027f22dab31d842be2dfd9550cb091cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b369ac8a9b718ff666d54c79462710"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType &gt; </td></tr>
<tr class="memitem:gaa0b369ac8a9b718ff666d54c79462710"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#gaa0b369ac8a9b718ff666d54c79462710">mpblocks::cuda::bitonic::sortSharedInc</a> (KeyType *d_DstKey, ValueType *d_DstVal, KeyType *d_SrcKey, ValueType *d_SrcVal, uint_t sharedLength)</td></tr>
<tr class="memdesc:gaa0b369ac8a9b718ff666d54c79462710"><td class="mdescLeft">&#160;</td><td class="mdescRight">bottom level of the bitonic sort  <a href="#gaa0b369ac8a9b718ff666d54c79462710">More...</a><br/></td></tr>
<tr class="separator:gaa0b369ac8a9b718ff666d54c79462710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711bd750c75e745f6fbe0f1cc9b05ca3"><td class="memTemplParams" colspan="2">template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ga711bd750c75e745f6fbe0f1cc9b05ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitonic.html#ga711bd750c75e745f6fbe0f1cc9b05ca3">mpblocks::cuda::bitonic::sortSharedInc</a> (KeyType *d_DstKey, KeyType *d_SrcKey, uint_t sharedLength)</td></tr>
<tr class="memdesc:ga711bd750c75e745f6fbe0f1cc9b05ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">bottom level of the bitonic sort  <a href="#ga711bd750c75e745f6fbe0f1cc9b05ca3">More...</a><br/></td></tr>
<tr class="separator:ga711bd750c75e745f6fbe0f1cc9b05ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains all the GPU (CUDA) kernels used to implement the bitonic sort algorithm, as well as a driver class for launching sort operations</p>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm">http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab73cd6e0410f9cb3334aefd4a9905291"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="portable_8h.html#ad54e07d96efd9a36dfca1a9f27776d62">__device__</a> void mpblocks::cuda::bitonic::compareSwap </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>valA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>valB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implements a "comparator": compares to keys and swaps them if they are not in the desired order </p>
<p>there is no validation of this fact but it is required that the less-than operator (&lt;) is defined for <code>KeyType</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyA</td><td>the first key to compare </td></tr>
    <tr><td class="paramname">valA</td><td>value associated with the first key </td></tr>
    <tr><td class="paramname">keyB</td><td>the second key to compare </td></tr>
    <tr><td class="paramname">valB</td><td>value associted with the second key </td></tr>
    <tr><td class="paramname">dir</td><td>the direction to sort, 1=ascending </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00052">52</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga88c9b60745c24c58da5294bc5ebf52b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="portable_8h.html#ad54e07d96efd9a36dfca1a9f27776d62">__device__</a> void mpblocks::cuda::bitonic::compareSwap </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType &amp;&#160;</td>
          <td class="paramname"><em>keyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compares to keys and swaps them if they are not in the desired order </p>
<p>there is no validation of this fact but it is required that the less-than operator (&lt;) is defined for <code>KeyType</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyA</td><td>the first key to compare </td></tr>
    <tr><td class="paramname">keyB</td><td>the second key to compare </td></tr>
    <tr><td class="paramname">dir</td><td>the direction to sort, 1=ascending </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00080">80</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ad8e13f8c3a5ad69912635d2a5fb73a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::mergeGlobal </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_DstVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_SrcVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sorts a bitonic series, this kernel is for a stride &gt;= SHARED_SIZE_LIMIT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstVal</td><td>array of sorted values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>bitonic array with split at size/2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcVal</td><td>values associated with d_SrcKey </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort in ascending or descending</td></tr>
  </table>
  </dd>
</dl>
<p>If A is an ascending sorted array and B is a descending sorted array, then [A,B] is a bitonic array. Here we merge A and B into a single sorted array</p>
<p>Note: usually this kernel is called with d_Dst... = d_Src... as it just merges results already stored in the destination buffer</p>
<p>Note: this kernel is used when the stride is too large to copy everything into shared memory, each thread just copies the two values they need to compare into global memory, performs the comparison/swap and then writes the results back to global memory </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00558">558</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga34b02960e723f46679d591e91d5fd985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::mergeGlobal </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sorts a bitonic series, this kernel is for a stride &gt;= SHARED_SIZE_LIMIT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>bitonic array with split at size/2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort in ascending or descending</td></tr>
  </table>
  </dd>
</dl>
<p>If A is an ascending sorted array and B is a descending sorted array, then [A,B] is a bitonic array. Here we merge A and B into a single sorted array</p>
<p>Note: usually this kernel is called with d_Dst... = d_Src... as it just merges results already stored in the destination buffer</p>
<p>Note: this kernel is used when the stride is too large to copy everything into shared memory, each thread just copies the two values they need to compare into global memory, performs the comparison/swap and then writes the results back to global memory </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00630">630</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae1b684229b12eee4d4f9ce59fb9bb285"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::mergeShared </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_DstVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_SrcVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sorts a bitonic series, this kernel is for size &gt; SHARED_SIZE_LIMIT and for a stride in [1, SHARED_SIZE_LIMIT/2] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstVal</td><td>array of sorted values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>bitonic array with split at size/2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcVal</td><td>values associated with d_SrcKey </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the stride betwen two elements a comparator works on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort in ascending or descending</td></tr>
  </table>
  </dd>
</dl>
<p>If A is an ascending sorted array and B is a descending sorted array, then [A,B] is a bitonic array. Here we merge A and B into a single sorted array</p>
<p>Note: usually this kernel is called with d_Dst... = d_Src... as it just merges results already stored in the destination buffer</p>
<p>Note: this kernel is used when the stride is small enough to copy everything it needs into global memory. It is assumed that the stride is actually SHARED_SIZE_LIMIT/2 (exactly) and this kernel will perform all iterations for strides smaller than the initial until stride = 0; </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00699">699</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b7672696f99e35730ee3f0af83e41e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::mergeShared </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sorts a bitonic series, this kernel is for size &gt; SHARED_SIZE_LIMIT and for a stride in [1, SHARED_SIZE_LIMIT/2] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>bitonic array with split at size/2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the stride betwen two elements a comparator works on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort in ascending or descending</td></tr>
  </table>
  </dd>
</dl>
<p>If A is an ascending sorted array and B is a descending sorted array, then [A,B] is a bitonic array. Here we merge A and B into a single sorted array</p>
<p>Note: usually this kernel is called with d_Dst... = d_Src... as it just merges results already stored in the destination buffer</p>
<p>Note: this kernel is used when the stride is small enough to copy everything it needs into global memory. It is assumed that the stride is actually SHARED_SIZE_LIMIT/2 (exactly) and this kernel will perform all iterations for strides smaller than the initial until stride = 0; </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00792">792</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf546b42a8c8b28e40a376ebf90af43a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::prepare </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used when arrayLength is not a power of two, it writes  to all values of d_SrcKey (which is an offset from of the actual source buffer) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>offset with buffer where padding starts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>value to write to all the overflow keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>number of values to write </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l01147">1147</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga075a351073741ddb3727c3257c9b307f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint_t mpblocks::cuda::bitonic::sort </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_DstVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_SrcVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>globalThread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel launcher, sorts an array of key/value pairs using the bitonic sort algorithm </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstVal</td><td>array of sorted values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>array of unsorted keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcVal</td><td>array of unsorted values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sharedLength</td><td>number of elements to store in shared arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort ascending or descending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">globalThread</td><td>number of threads per block for global merge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm">http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm</a> </dd></dl>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00870">870</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6afcc03653463ced68a00866e763da40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint_t mpblocks::cuda::bitonic::sort </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>globalThread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel launcher, sorts an array of key/value pairs using the bitonic sort algorithm </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_DstKey</td><td>array of sorted keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_SrcKey</td><td>array of unsorted keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>the length of each array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sharedLength</td><td>number of elements to store in shared arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>whether we should sort ascending or descending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">globalThread</td><td>number of threads per block for global merge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm">http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm</a> </dd></dl>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l01012">1012</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6674656e30bc37adf3f8f488b8ab9d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::sortShared </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_DstVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_SrcVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>single kernel (unified) bitonic sort </p>
<p>If the entire array to be sorted fits in shared memory, then we can perform the entire operation with only one kernel call (that's this kernel). If the entire array does not fit in shared memory then some of the comparator networks will have a stride large enough to cross block boundaries, so we have to divide and conquor (see the other kernels for this method) </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00108">108</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga027f22dab31d842be2dfd9550cb091cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::sortShared </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>single kernel (unified) bitonic sort </p>
<p>If the entire array to be sorted fits in shared memory, then we can perform the entire operation with only one kernel call (that's this kernel). If the entire array does not fit in shared memory then some of the comparator networks will have a stride large enough to cross block boundaries, so we have to divide and conquor (see the other kernels for this method) </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00191">191</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0b369ac8a9b718ff666d54c79462710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::sortSharedInc </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_DstVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>d_SrcVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bottom level of the bitonic sort </p>
<p>Since this kernel works in shared memory we'd like to use it as much as possible, so what we do is divide up the entire array that we want to sort and only sort it in sections that are small enough to fit in shared memory. However, we sort every other block in a different direction. As a result, each pair of results forms a bitonic series. We can then efficiently merge each pair of blocks into a sorted series, which we continue doing until the entire array is sorted.</p>
<p>Note: the next stage (Bitonic merge) accepts both ascending | descending and descending | ascending bitonic series </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00283">283</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga711bd750c75e745f6fbe0f1cc9b05ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fakecuda_8h.html#a75e2d5456e52f5c9703fc88479472e55">__global__</a> void mpblocks::cuda::bitonic::sortSharedInc </td>
          <td>(</td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_DstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyType *&#160;</td>
          <td class="paramname"><em>d_SrcKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>sharedLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bottom level of the bitonic sort </p>
<p>Since this kernel works in shared memory we'd like to use it as much as possible, so what we do is divide up the entire array that we want to sort and only sort it in sections that are small enough to fit in shared memory. However, we sort every other block in a different direction. As a result, each pair of results forms a bitonic series. We can then efficiently merge each pair of blocks into a sorted series, which we continue doing until the entire array is sorted.</p>
<p>Note: the next stage (Bitonic merge) accepts both ascending | descending and descending | ascending bitonic series </p>

<p>Definition at line <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html#l00421">421</a> of file <a class="el" href="cuda_2bitonic_2kernels_8cu_8hpp_source.html">kernels.cu.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Mar 22 2015 22:47:45 for cheshirekow by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
