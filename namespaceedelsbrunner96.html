<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cheshirekow: edelsbrunner96 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cheshirekow
   &#160;<span id="projectnumber">v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceedelsbrunner96.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">edelsbrunner96 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceedelsbrunner96_1_1iter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96_1_1iter.html">iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceedelsbrunner96_1_1simplex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96_1_1simplex.html">simplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedelsbrunner96_1_1_breadth_first.html">BreadthFirst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structedelsbrunner96_1_1_example_traits.html">ExampleTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example of a traits class suitable for instantiation an edelsbrunner triangulation object.  <a href="structedelsbrunner96_1_1_example_traits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedelsbrunner96_1_1_exhaustive_simplex_distance.html">ExhaustiveSimplexDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the distance of a point to a simplex by expanding all combinations of vertices and evaluating the distance to the lower-dimensional simplex feature represented by that combination of vertices.  <a href="classedelsbrunner96_1_1_exhaustive_simplex_distance.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structedelsbrunner96_1_1_facet.html">Facet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A facet is a (d-1)-dimensional simplex.  <a href="structedelsbrunner96_1_1_facet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedelsbrunner96_1_1_induced_subcomplex.html">InducedSubcomplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The induced subcomplex of a facet between two simplices is the set of all simplices in the triangulation whose vertices are composed of those from the two simplices in question.  <a href="classedelsbrunner96_1_1_induced_subcomplex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structedelsbrunner96_1_1_simplex_base.html">SimplexBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplex in the triangulation. A simplex is the convex hull of Ndim+1 points in R^NDim.  <a href="structedelsbrunner96_1_1_simplex_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedelsbrunner96_1_1_simplex_fill.html">SimplexFill</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience for setting vertices of a simplex.  <a href="classedelsbrunner96_1_1_simplex_fill.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa3592490430fa0cab089b9babdfdb502"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Derived , class Iterator &gt; </td></tr>
<tr class="memitem:aa3592490430fa0cab089b9babdfdb502"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#aa3592490430fa0cab089b9babdfdb502">BarycentricProjection</a> (typename Traits::Storage &amp;storage, const typename Traits::Point &amp;x, Iterator begin, Iterator end, Eigen::MatrixBase&lt; Derived &gt; *L, typename Traits::Point *x_proj)</td></tr>
<tr class="memdesc:aa3592490430fa0cab089b9babdfdb502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a query point, <code>x</code> and a set of vertex points, V, return the point y in hull(V) which is closest to <code>x_q</code>.  <a href="#aa3592490430fa0cab089b9babdfdb502">More...</a><br/></td></tr>
<tr class="separator:aa3592490430fa0cab089b9babdfdb502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17fcb157270845d9fdb7a8c57ce2903"><td class="memTemplParams" colspan="2">template&lt;class Traits , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac17fcb157270845d9fdb7a8c57ce2903"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#ac17fcb157270845d9fdb7a8c57ce2903">BreadthFirstSearch</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef simplex_ref, OutputIterator out)</td></tr>
<tr class="memdesc:ac17fcb157270845d9fdb7a8c57ce2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all simplices by breadth first search starting at <code>simplex_ref</code>.  <a href="#ac17fcb157270845d9fdb7a8c57ce2903">More...</a><br/></td></tr>
<tr class="separator:ac17fcb157270845d9fdb7a8c57ce2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45dca150c5d979a6f30c908cce01f17"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Container &gt; </td></tr>
<tr class="memitem:ab45dca150c5d979a6f30c908cce01f17"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename <br class="typebreak"/>
Traits::SimplexRef, typename <br class="typebreak"/>
Traits::SimplexRef &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#ab45dca150c5d979a6f30c908cce01f17">BuildHorizonRidge</a> (typename Traits::Storage &amp;storage, Container &amp;visible_hull)</td></tr>
<tr class="memdesc:ab45dca150c5d979a6f30c908cce01f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the horizon ridge, which is the set of all <em>edges</em> which border the x-visible hull.  <a href="#ab45dca150c5d979a6f30c908cce01f17">More...</a><br/></td></tr>
<tr class="separator:ab45dca150c5d979a6f30c908cce01f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42091c8bf41ff939e9daea58c9912b7b"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Container &gt; </td></tr>
<tr class="memitem:a42091c8bf41ff939e9daea58c9912b7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a42091c8bf41ff939e9daea58c9912b7b">DemoteHullSimplices</a> (typename Traits::Storage &amp;storage, Container &amp;visible_hull, typename Traits::PointRef point_ref)</td></tr>
<tr class="memdesc:a42091c8bf41ff939e9daea58c9912b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each infinite simplex references in <code>hull_simplices</code>, replace the null vertex with the vertex pointed to by <code>point_ref</code>.  <a href="#a42091c8bf41ff939e9daea58c9912b7b">More...</a><br/></td></tr>
<tr class="separator:a42091c8bf41ff939e9daea58c9912b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d88ff6a5910ee4e8e37f3cc5f019a6"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ad0d88ff6a5910ee4e8e37f3cc5f019a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#ad0d88ff6a5910ee4e8e37f3cc5f019a6">FeatureWalk</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef s_0, InputIterator Vf_begin, InputIterator Vf_end, OutputIterator out)</td></tr>
<tr class="memdesc:ad0d88ff6a5910ee4e8e37f3cc5f019a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sub-simplex feature and a simplex adjacent to that feature, enumerate all simplices that are adjacent to that feature.  <a href="#ad0d88ff6a5910ee4e8e37f3cc5f019a6">More...</a><br/></td></tr>
<tr class="separator:ad0d88ff6a5910ee4e8e37f3cc5f019a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afc9a262c573e69d0b4120e6426fd9e"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Container &gt; </td></tr>
<tr class="memitem:a9afc9a262c573e69d0b4120e6426fd9e"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; typename <br class="typebreak"/>
Traits::SimplexRef &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a9afc9a262c573e69d0b4120e6426fd9e">FillHorizonWedges</a> (typename Traits::Storage &amp;storage, Container &amp;horizon_ridge, typename Traits::PointRef point_ref)</td></tr>
<tr class="memdesc:a9afc9a262c573e69d0b4120e6426fd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each simplex pair (s1,s2) in , fill the empty wedge that was created when s1 was demoted to a non-infinite simplex.  <a href="#a9afc9a262c573e69d0b4120e6426fd9e">More...</a><br/></td></tr>
<tr class="separator:a9afc9a262c573e69d0b4120e6426fd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a267197a55109dae755d69a95310d0"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:af5a267197a55109dae755d69a95310d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#af5a267197a55109dae755d69a95310d0">FindFillNeighbor</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef s_ref, typename Traits::PointRef v_ref, typename Traits::PointRef peak_ref)</td></tr>
<tr class="memdesc:af5a267197a55109dae755d69a95310d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the neighbor of a fill simplex that is across from v_ref.  <a href="#af5a267197a55109dae755d69a95310d0">More...</a><br/></td></tr>
<tr class="separator:af5a267197a55109dae755d69a95310d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bbf0125b3753ca9e1d7d714febe6eb"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:a80bbf0125b3753ca9e1d7d714febe6eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a80bbf0125b3753ca9e1d7d714febe6eb">FindWedgeNeighbor</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef wedge_ref, int i)</td></tr>
<tr class="memdesc:a80bbf0125b3753ca9e1d7d714febe6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a simplex which fills an empty wedge created by demotion of a simplex along the horizon ridge, find the i'th neighbor by walking around the common edge which contains the peak vertex.  <a href="#a80bbf0125b3753ca9e1d7d714febe6eb">More...</a><br/></td></tr>
<tr class="separator:a80bbf0125b3753ca9e1d7d714febe6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90df932b57b466388ed23f021444617"><td class="memTemplParams" colspan="2">template&lt;typename Traits , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac90df932b57b466388ed23f021444617"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#ac90df932b57b466388ed23f021444617">FuzzyWalk</a> (typename Traits::Storage &amp;storage, const typename Traits::SimplexRef s_0, const typename Traits::Point &amp;x_q, const typename Traits::Scalar epsilon, OutputIterator out)</td></tr>
<tr class="memdesc:ac90df932b57b466388ed23f021444617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a simplex in a triangulation and a query point, walk the triangulation in the direction of x_q until we find the set of simplices that the query intersects.  <a href="#ac90df932b57b466388ed23f021444617">More...</a><br/></td></tr>
<tr class="separator:ac90df932b57b466388ed23f021444617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff377fe429c90d40bbf2edf9b21ff5d"><td class="memTemplParams" colspan="2">template&lt;typename Traits , class OutputIterator &gt; </td></tr>
<tr class="memitem:a9ff377fe429c90d40bbf2edf9b21ff5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a9ff377fe429c90d40bbf2edf9b21ff5d">FuzzyWalk_</a> (typename Traits::Storage &amp;storage, const typename Traits::SimplexRef s_0, const typename Traits::Point &amp;x_q, const typename Traits::Scalar epsilon, std::list&lt; typename Traits::SimplexRef &gt; &amp;search_queue, OutputIterator out)</td></tr>
<tr class="memdesc:a9ff377fe429c90d40bbf2edf9b21ff5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation, exposed so that the search_queue can be examined in tests.  <a href="#a9ff377fe429c90d40bbf2edf9b21ff5d">More...</a><br/></td></tr>
<tr class="separator:a9ff377fe429c90d40bbf2edf9b21ff5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aad55bd1e496a3fd96f458a53ff41ec"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:a3aad55bd1e496a3fd96f458a53ff41ec"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a3aad55bd1e496a3fd96f458a53ff41ec">FuzzyWalkInsert</a> (typename Traits::Storage &amp;storage, const typename Traits::SimplexRef s_0, const typename Traits::PointRef x_ref, const typename Traits::Scalar epsilon)</td></tr>
<tr class="memdesc:a3aad55bd1e496a3fd96f458a53ff41ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fuzzy walk to get the set of simplices intersecting the query point, then insert the point into the triangulation.  <a href="#a3aad55bd1e496a3fd96f458a53ff41ec">More...</a><br/></td></tr>
<tr class="separator:a3aad55bd1e496a3fd96f458a53ff41ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e49e7e2b5b3960df33bbb80e2250b38"><td class="memTemplParams" colspan="2">template&lt;class Traits , class OutputIterator &gt; </td></tr>
<tr class="memitem:a4e49e7e2b5b3960df33bbb80e2250b38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a4e49e7e2b5b3960df33bbb80e2250b38">GetVisibleHull</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef s_0, const typename Traits::Point &amp;x_q, OutputIterator out)</td></tr>
<tr class="memdesc:a4e49e7e2b5b3960df33bbb80e2250b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting at some x-visible hull simplex, return a list of all x-visible hull simplices.  <a href="#a4e49e7e2b5b3960df33bbb80e2250b38">More...</a><br/></td></tr>
<tr class="separator:a4e49e7e2b5b3960df33bbb80e2250b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87efd3c00d4901835ee9596b0e64f85"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:af87efd3c00d4901835ee9596b0e64f85"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#af87efd3c00d4901835ee9596b0e64f85">InsertInside</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef simplex_ref, typename Traits::PointRef point_ref)</td></tr>
<tr class="memdesc:af87efd3c00d4901835ee9596b0e64f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a point into a simplex, performs 1-to-n+1 flip, and performs the delaunay maintenance on the modified graph.  <a href="#af87efd3c00d4901835ee9596b0e64f85">More...</a><br/></td></tr>
<tr class="separator:af87efd3c00d4901835ee9596b0e64f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddc046546c155f4400f944f3b8b8de2"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:acddc046546c155f4400f944f3b8b8de2"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#acddc046546c155f4400f944f3b8b8de2">InsertOutside</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef simplex_ref, typename Traits::PointRef point_ref)</td></tr>
<tr class="memdesc:acddc046546c155f4400f944f3b8b8de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a point outside of the hull of the current point set. Note that <code>simplex_ref</code> must point to a hull facet which is visible by the point to insert.  <a href="#acddc046546c155f4400f944f3b8b8de2">More...</a><br/></td></tr>
<tr class="separator:acddc046546c155f4400f944f3b8b8de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3040d8984695c245dc14f0ad3c948427"><td class="memTemplParams" colspan="2">template&lt;class Traits , class Iterator &gt; </td></tr>
<tr class="memitem:a3040d8984695c245dc14f0ad3c948427"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a3040d8984695c245dc14f0ad3c948427">InsertReplace</a> (typename Traits::Storage &amp;storage, typename Traits::PointRef point_ref, Iterator S_begin, Iterator S_end)</td></tr>
<tr class="memdesc:a3040d8984695c245dc14f0ad3c948427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a point into the triangulation, replacing the given simplex set which intersect the new point.  <a href="#a3040d8984695c245dc14f0ad3c948427">More...</a><br/></td></tr>
<tr class="separator:a3040d8984695c245dc14f0ad3c948427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf7db9ad09d0cde530656c3fbb2f005"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:acaf7db9ad09d0cde530656c3fbb2f005"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#acaf7db9ad09d0cde530656c3fbb2f005">IsVisible</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef s_ref, const typename Traits::Point &amp;x_q, typename Traits::Scalar epsilon=0.0)</td></tr>
<tr class="memdesc:acaf7db9ad09d0cde530656c3fbb2f005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a hull simplex, return true if it is visible by the query point.  <a href="#acaf7db9ad09d0cde530656c3fbb2f005">More...</a><br/></td></tr>
<tr class="separator:acaf7db9ad09d0cde530656c3fbb2f005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc36794b6158b64de6b63e565aeb15b4"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:acc36794b6158b64de6b63e565aeb15b4"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#acc36794b6158b64de6b63e565aeb15b4">LineWalk</a> (typename Traits::Storage &amp;storage, typename Traits::SimplexRef s_0, const typename Traits::Point &amp;p)</td></tr>
<tr class="memdesc:acc36794b6158b64de6b63e565aeb15b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting at the median point of simplex <code>s_0</code>, walk the triangulation in the direction of <code>p</code> until the simplex containing <code>p</code> is found. Return that simplex. Note that the returned simplex may be an "infinite" simplex, i.e. a sentinal for a boundary facet of the convex hull.  <a href="#acc36794b6158b64de6b63e565aeb15b4">More...</a><br/></td></tr>
<tr class="separator:acc36794b6158b64de6b63e565aeb15b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba471c863a234f84143f39a3011f4de"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:acba471c863a234f84143f39a3011f4de"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#acba471c863a234f84143f39a3011f4de">Maintain</a> (typename Traits::Storage &amp;storage, typename Traits::PointRef point_ref, typename Traits::SimplexRef return_ref, std::list&lt; <a class="el" href="structedelsbrunner96_1_1_facet.html">Facet</a>&lt; Traits &gt;&gt; &amp;link_facets)</td></tr>
<tr class="memdesc:acba471c863a234f84143f39a3011f4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">While the link of the specified point is not locally Delaunay, continue flipping locally non-Delaunay facets.  <a href="#acba471c863a234f84143f39a3011f4de">More...</a><br/></td></tr>
<tr class="separator:acba471c863a234f84143f39a3011f4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cca32ed0997e6785e78a7246c687f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a8cca32ed0997e6785e78a7246c687f64">pass</a> (std::initializer_list&lt; int &gt; &amp;&amp;)</td></tr>
<tr class="memdesc:a8cca32ed0997e6785e78a7246c687f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trick to allow parameter pack expansion for filling.  <a href="#a8cca32ed0997e6785e78a7246c687f64">More...</a><br/></td></tr>
<tr class="separator:a8cca32ed0997e6785e78a7246c687f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da2a3353189e269100c7f74a4d2f50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47da2a3353189e269100c7f74a4d2f50"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a47da2a3353189e269100c7f74a4d2f50">signum</a> (T val)</td></tr>
<tr class="separator:a47da2a3353189e269100c7f74a4d2f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df7c680429b27dea14106fd2f42244f"><td class="memTemplParams" colspan="2">template&lt;class Traits , class OutputIterator &gt; </td></tr>
<tr class="memitem:a9df7c680429b27dea14106fd2f42244f"><td class="memTemplItemLeft" align="right" valign="top">Traits::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#a9df7c680429b27dea14106fd2f42244f">SimplexDistance</a> (typename Traits::Storage &amp;storage, const typename Traits::Point &amp;x, const typename Traits::SimplexRef s_ref, typename Traits::Point *x_proj, OutputIterator V_out)</td></tr>
<tr class="memdesc:a9df7c680429b27dea14106fd2f42244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of &lt;= NDim+1 vertices, compute the distance of the query point to the convex hull of the vertex set.  <a href="#a9df7c680429b27dea14106fd2f42244f">More...</a><br/></td></tr>
<tr class="separator:a9df7c680429b27dea14106fd2f42244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad692e56bab9872d7fe6a09385c611341"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:ad692e56bab9872d7fe6a09385c611341"><td class="memTemplItemLeft" align="right" valign="top">Traits::SimplexRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceedelsbrunner96.html#ad692e56bab9872d7fe6a09385c611341">Triangulate</a> (typename Traits::Storage &amp;storage, std::initializer_list&lt; typename Traits::PointRef &gt; refs)</td></tr>
<tr class="memdesc:ad692e56bab9872d7fe6a09385c611341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a triangulation with NDim+1 points and return the simplex.  <a href="#ad692e56bab9872d7fe6a09385c611341">More...</a><br/></td></tr>
<tr class="separator:ad692e56bab9872d7fe6a09385c611341"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa3592490430fa0cab089b9babdfdb502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Derived , class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::BarycentricProjection </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::Point *&#160;</td>
          <td class="paramname"><em>x_proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a query point, <code>x</code> and a set of vertex points, V, return the point y in hull(V) which is closest to <code>x_q</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>the storage model </td></tr>
    <tr><td class="paramname">x</td><td>the query point </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to the first vertex reference </td></tr>
    <tr><td class="paramname">end</td><td>iterator to the past-the-end vertex reference </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simplex_8hpp_source.html#l00177">177</a> of file <a class="el" href="simplex_8hpp_source.html">simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac17fcb157270845d9fdb7a8c57ce2903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>simplex_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all simplices by breadth first search starting at <code>simplex_ref</code>. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00445">445</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab45dca150c5d979a6f30c908cce01f17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;typename Traits::SimplexRef, typename Traits::SimplexRef&gt; &gt; edelsbrunner96::BuildHorizonRidge </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>visible_hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the horizon ridge, which is the set of all <em>edges</em> which border the x-visible hull. </p>
<p>An edge is a set of (N+1-2) vertices. For simplices along the horizon ridge, one of the missing vertices is the infinite vertex, or, if the simplex is newly demoted, the vertex that was added. We go through all of the demoted simplices, and make a list of those that are on the horizon ridge (i.e. the boundary of the demoted subcomplex). </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00224">224</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42091c8bf41ff939e9daea58c9912b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::DemoteHullSimplices </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>visible_hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each infinite simplex references in <code>hull_simplices</code>, replace the null vertex with the vertex pointed to by <code>point_ref</code>. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00177">177</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d88ff6a5910ee4e8e37f3cc5f019a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::FeatureWalk </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Vf_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>Vf_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a sub-simplex feature and a simplex adjacent to that feature, enumerate all simplices that are adjacent to that feature. </p>
<p>A "feature" is a simplex s = conv(V), of |V| &lt; NDim+1 vertices. It is a simplex of lower dimension than the embedding dimension of the triangulation. As an example, for a triangulation in 3 dimensions, a simplex is a tetrahedron, which is the convex hull of four vertices. The (3-1=2)-dimensional features of this simplex are it's triangle facets. The (3-2=1)-dimensional features of this simplex are it's line-segment edges. The (3-3=0)-dimensional features are it's vertices.</p>
<p>Given a simplex S, with vertex set V_S, and a feature with vertex set V_f, we identify the set of vertices V = V_S \ V_f. For each vertex v in V, the neighbor of S across from v shares all vertices V \ v. In particular, it shares V_f. We enumerate simplices of a common feature by breadth-first utilizing this fact. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00168">168</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9afc9a262c573e69d0b4120e6426fd9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;typename Traits::SimplexRef&gt; edelsbrunner96::FillHorizonWedges </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>horizon_ridge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each simplex pair (s1,s2) in , fill the empty wedge that was created when s1 was demoted to a non-infinite simplex. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00246">246</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5a267197a55109dae755d69a95310d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::FindFillNeighbor </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>v_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>peak_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the neighbor of a fill simplex that is across from v_ref. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00579">579</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80bbf0125b3753ca9e1d7d714febe6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::FindWedgeNeighbor </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>wedge_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a simplex which fills an empty wedge created by demotion of a simplex along the horizon ridge, find the i'th neighbor by walking around the common edge which contains the peak vertex. </p>
<p>The algorithm for this is based on the horizon-ridge algorithm from Clarkson93. For each new simplex along the horizon ridge that we need to find the neighbor of, the neighbor that we need will lie across a <em>facet</em> of that simplex. That facet is composed of N vertices, one of which is the peak vertex (the newly added point). If we remove the peak vertex we are left with (N-1) vertices which we will call the "pivot edge". We will do a walk around this pivot edge until we find the neighboring simplex.</p>
<p>From our starting simplex we move to the neighbor across the infinite vertex. This neighbor shares the pivot edge, and one other vertex in common with the starting simplex. Incidentally, it is also a recently demoted simplex. We continue the walk by following that other vertex. A proof is given in the Clarkson93 paper that the walk <em>must</em> end at the desired neighbor of the starting simplex.</p>
<p>This walk is illustrated in 2d in the following ascii art. We start at simplex [0] and are looking for the neighbor across the facet {x,inf}. The relevant edge we will walk "around" is {x}. Note that we define an edge as the NDim points of the common facet, minus the infinite vertex. In 2d this is a set of one vertex, or, simply, a point. In 2d, an edge is a point... confusing, I know.</p>
<p>In any case we start at simplex [0] and walk to the neighbor across from (inf) which is simplex [1] in the diagram. Simplex [1] contains exactly one vertex which is on the facet between [0] and [1] and is not (x). We identify that vertex (a), and then move to the neighbor across that vertex, [2]. Again simplex [2] and simplex [1] share only a single vertex which is on the their common facet but is not (x). We identify that vertex (b) and move to the neighbor across (b), in this case simplex [3]. We continue this walk until we reach simplex [4], which is the first infinite simplex in this walk around the edge. Simplex [4] is the neighbor across from [0] that we were searching for.</p>
<div class="fragment"><div class="line">              (inf)           [.] simplex</div>
<div class="line">               |              (.) <a class="code" href="namespacempblocks_1_1cuda__cert.html#a90cde387d34bd333fb21f3d008106297">vertex</a></div>
<div class="line">               |</div>
<div class="line">      [4]   (<a class="code" href="namespacempblocks_1_1cuda_1_1polynomial_1_1param__key.html#a7af52b985c86b22bf4ef49077a7e4a7e">x</a>)|     [0]</div>
<div class="line">             <span class="comment">//\\</span></div>
<div class="line"><span class="comment">          /  /  \  \</span></div>
<div class="line"><span class="comment">       /    /    \    \</span></div>
<div class="line"><span class="comment">    /      /      \      \</span></div>
<div class="line"><span class="comment"> /   [3]  /   [2]  \  [1]   \</span></div>
<div class="line"><span class="comment">(d)      (c)       (b)      (a)</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00368">368</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac90df932b57b466388ed23f021444617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::FuzzyWalk </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a simplex in a triangulation and a query point, walk the triangulation in the direction of x_q until we find the set of simplices that the query intersects. </p>
<p>We return all simplices which are within <code>epsilon</code> distance from <code>x_q</code>. The search is a greedy walk through the triangulation. Starting at <code>s_0</code>, we find the feature of the simplex nearest to x_q. We then queue up all simplices that are adjacent to that feature. A feature is a sub-simplex such as a facet, edge, or lower-dimensional hull of some subset of the vertex set (down to a single vertex). For instance, if the query point is closest to a facet of s_0, we only queue up the neighbor of s_0 across that facet. If x_q is closest to a vertex of s_0, we queue up all simplices that share that vertex.</p>
<p>param storage the storage model param s_0 the simplex to start the walk at param epsilon the radius of fuzz for which we consider something to intersect param x_q the query point param[out] out iterator where we write the output set of simplices </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00299">299</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ff377fe429c90d40bbf2edf9b21ff5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::FuzzyWalk_ </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename Traits::SimplexRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>search_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation, exposed so that the search_queue can be examined in tests. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00227">227</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3aad55bd1e496a3fd96f458a53ff41ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::FuzzyWalkInsert </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>x_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fuzzy walk to get the set of simplices intersecting the query point, then insert the point into the triangulation. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00724">724</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e49e7e2b5b3960df33bbb80e2250b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::GetVisibleHull </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting at some x-visible hull simplex, return a list of all x-visible hull simplices. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00356">356</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af87efd3c00d4901835ee9596b0e64f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::InsertInside </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>simplex_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a point into a simplex, performs 1-to-n+1 flip, and performs the delaunay maintenance on the modified graph. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00498">498</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acddc046546c155f4400f944f3b8b8de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::InsertOutside </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>simplex_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a point outside of the hull of the current point set. Note that <code>simplex_ref</code> must point to a hull facet which is visible by the point to insert. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00411">411</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3040d8984695c245dc14f0ad3c948427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::InsertReplace </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>S_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>S_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a point into the triangulation, replacing the given simplex set which intersect the new point. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00619">619</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acaf7db9ad09d0cde530656c3fbb2f005"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool edelsbrunner96::IsVisible </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::Scalar&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a hull simplex, return true if it is visible by the query point. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00310">310</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc36794b6158b64de6b63e565aeb15b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::LineWalk </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting at the median point of simplex <code>s_0</code>, walk the triangulation in the direction of <code>p</code> until the simplex containing <code>p</code> is found. Return that simplex. Note that the returned simplex may be an "infinite" simplex, i.e. a sentinal for a boundary facet of the convex hull. </p>
<p>Starting at centroid of simplex <code>s_0</code>, walk the triangulation in the direction of <code>p</code> until the simplex containing <code>p</code> is found. Return that simplex. Note that the returned simplex may be an "infinite" simplex, i.e. a sentinal for a boundary facet of the convex hull. </p>

<p>Definition at line <a class="el" href="line__walker_8hpp_source.html#l00042">42</a> of file <a class="el" href="line__walker_8hpp_source.html">line_walker.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acba471c863a234f84143f39a3011f4de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::Maintain </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::PointRef&#160;</td>
          <td class="paramname"><em>point_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>return_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; Facet&lt; Traits &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>link_facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>While the link of the specified point is not locally Delaunay, continue flipping locally non-Delaunay facets. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00087">87</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cca32ed0997e6785e78a7246c687f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void edelsbrunner96::pass </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A trick to allow parameter pack expansion for filling. </p>

<p>Definition at line <a class="el" href="simplex_8hpp_source.html#l00047">47</a> of file <a class="el" href="simplex_8hpp_source.html">simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47da2a3353189e269100c7f74a4d2f50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int edelsbrunner96::signum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="induced__subcomplex_8hpp_source.html#l00160">160</a> of file <a class="el" href="induced__subcomplex_8hpp_source.html">induced_subcomplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9df7c680429b27dea14106fd2f42244f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::Scalar edelsbrunner96::SimplexDistance </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::SimplexRef&#160;</td>
          <td class="paramname"><em>s_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::Point *&#160;</td>
          <td class="paramname"><em>x_proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>V_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of &lt;= NDim+1 vertices, compute the distance of the query point to the convex hull of the vertex set. </p>
<p>We use a reduced version of GJK to compute the distance to the hull. We start at the nearest vertex and build up <em>features</em> until we find the nearest feature. A feature is a vertex, a line segment between two vertices, a triangle between three vertices, a tetrahedron between four vertices, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>the triangulation storage class </td></tr>
    <tr><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramname">V</td><td>the vertex set of the simplex </td></tr>
    <tr><td class="paramname">out</td><td>output iterator, the vertex set of the nearest feature is written here </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simplex_8hpp_source.html#l00213">213</a> of file <a class="el" href="simplex_8hpp_source.html">simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad692e56bab9872d7fe6a09385c611341"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::SimplexRef edelsbrunner96::Triangulate </td>
          <td>(</td>
          <td class="paramtype">typename Traits::Storage &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename Traits::PointRef &gt;&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a triangulation with NDim+1 points and return the simplex. </p>
<p>The triangulation is actually composed of NDim+2 simplices. In 2d this is drawn in ascii art below. </p>
<div class="fragment"><div class="line">                    (inf)             [.] simplex</div>
<div class="line">                     |                (.) <a class="code" href="namespacempblocks_1_1cuda__cert.html#a90cde387d34bd333fb21f3d008106297">vertex</a></div>
<div class="line">                     |</div>
<div class="line">                     |(2)</div>
<div class="line">                    / \</div>
<div class="line">             [1]   /   \    [0]</div>
<div class="line">                  /     \</div>
<div class="line">                 /  [3]  \</div>
<div class="line">(inf) ----------/_________\------------ (inf)</div>
<div class="line">             (0)           (1)</div>
<div class="line"></div>
<div class="line">                    [2]</div>
</div><!-- fragment --><p> Note that there are (NDim=2 + 2) = 4 simplices (triangles) generated. The triangle formed by the three vertices is [3] = conv({(0),(1),(2)}). There are three additional meta-simplices. Each one is formed by two of the vertices, with the addition of the designated "infinite" vertex as the third. In this way the entire space of R^2 is covered. Note that these infinite simplices are degenerate: their circumcenter and circumradius are undefined. This is useful, however, to ensure that the entire space of R^2 is covered by an element in the tesselation. </p>

<p>Definition at line <a class="el" href="triangulation_8hpp_source.html#l00040">40</a> of file <a class="el" href="triangulation_8hpp_source.html">triangulation.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceedelsbrunner96.html">edelsbrunner96</a></li>
    <li class="footer">Generated on Sun Mar 22 2015 22:47:45 for cheshirekow by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
